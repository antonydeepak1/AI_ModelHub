# -*- coding: utf-8 -*-
"""audio denoiser and voice clone backend.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1Kp6pZigBAslsSthhFBaQpyQrWJOZuozh
"""

# Install required dependencies (for Colab or local setup)
!pip install fastapi uvicorn nest_asyncio pyngrok gradio torchaudio TTS noisereduce librosa soundfile --quiet

# Imports
import os
import uvicorn
import torch
import librosa
import noisereduce as nr
import soundfile as sf
import tempfile
import nest_asyncio
from fastapi import FastAPI, UploadFile, File, Form
from fastapi.responses import FileResponse, JSONResponse
from fastapi.middleware.cors import CORSMiddleware
from pyngrok import ngrok
from TTS.api import TTS

# Enable nested event loops for Colab/Notebook environments
nest_asyncio.apply()

# Prompt for ngrok token
ngrok_token = input("üîê Enter your ngrok auth token: ").strip()
if ngrok_token:
    os.environ["NGROK_AUTHTOKEN"] = ngrok_token
    ngrok.set_auth_token(ngrok_token)
else:
    print("‚ö†Ô∏è Ngrok token not provided. Tunnel may not work.")

# Agree to Coqui license
os.environ["COQUI_TOS_AGREED"] = "1"

# Load XTTS model
device = "cuda" if torch.cuda.is_available() else "cpu"
try:
    tts = TTS("tts_models/multilingual/multi-dataset/xtts_v2").to(device)
except Exception as e:
    from TTS.tts.configs.xtts_config import XttsConfig
    import torch.serialization
    torch.serialization.add_safe_globals([XttsConfig])
    original_torch_load = torch.load

    def patched_torch_load(*args, **kwargs):
        kwargs['weights_only'] = False
        return original_torch_load(*args, **kwargs)

    torch.load = patched_torch_load
    tts = TTS("tts_models/multilingual/multi-dataset/xtts_v2").to(device)
    torch.load = original_torch_load

# Initialize FastAPI
app = FastAPI(title="üéôÔ∏è Voice Cloning + Audio Denoiser API")

# CORS middleware for cross-origin requests
app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

# Root endpoint (fix for "Method Not Allowed" when visiting base URL)
@app.get("/")
def read_root():
    return {"message": "Welcome to the Voice Cloning API! Visit /docs to try it out."}

# Voice Cloning Endpoint
@app.post("/clone/")
async def clone_voice(text: str = Form(...), audio: UploadFile = File(...)):
    try:
        with tempfile.NamedTemporaryFile(delete=False, suffix=".wav") as tmp:
            tmp.write(await audio.read())
            ref_audio_path = tmp.name

        output_path = "cloned_output.wav"
        tts.tts_to_file(text=text, speaker_wav=ref_audio_path, language="en", file_path=output_path)

        return FileResponse(output_path, media_type="audio/wav", filename="cloned_output.wav")
    except Exception as e:
        return JSONResponse(status_code=500, content={"error": f"Voice cloning failed: {str(e)}"})

# Audio Denoising Endpoint
@app.post("/denoise/")
async def denoise_audio(audio: UploadFile = File(...)):
    try:
        with tempfile.NamedTemporaryFile(delete=False, suffix=".wav") as tmp:
            tmp.write(await audio.read())
            tmp_path = tmp.name

        data, sample_rate = librosa.load(tmp_path, sr=None)

        # Convert to mono if stereo
        if len(data.shape) == 2:
            data = data[:, 0]

        noise_clip = data[:int(sample_rate * 0.5)]
        reduced_noise = nr.reduce_noise(y=data, sr=sample_rate, y_noise=noise_clip)

        output_file = "denoised_output.wav"
        sf.write(output_file, reduced_noise, sample_rate)

        return FileResponse(output_file, media_type="audio/wav", filename="denoised_output.wav")
    except Exception as e:
        return JSONResponse(status_code=500, content={"error": f"Denoising failed: {str(e)}"})

# Run FastAPI server with ngrok tunnel
port = 8000
public_url = ngrok.connect(port, bind_tls=True)
print(f"\nüöÄ API is live at: {public_url}/docs")

# Start the server
config = uvicorn.Config(app, host="0.0.0.0", port=port, log_level="info")
server = uvicorn.Server(config)
await server.serve()