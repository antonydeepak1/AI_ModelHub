# -*- coding: utf-8 -*-
"""audio denoiser and voice clone.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1F4oiei1HL_nC2EB0gRm1rRAz4UDcFUI5
"""

# üì¶ Install (for Colab or Jupyter environments only)
!pip install numpy==1.26.4 fastapi uvicorn[standard] noisereduce librosa soundfile pyngrok python-multipart TTS --quiet

# üöÄ FastAPI app with CORS + Ngrok + Audio Denoise + Voice Clone

from fastapi import FastAPI, File, UploadFile, Request, Form
from fastapi.middleware.cors import CORSMiddleware
from fastapi.responses import FileResponse, RedirectResponse
import uvicorn
import librosa
import noisereduce as nr
import soundfile as sf
import numpy as np
import os
import torch
from TTS.api import TTS
from pyngrok import ngrok
import threading

# ‚úÖ Create FastAPI app
app = FastAPI(title="üéß Audio Denoiser & üéôÔ∏è Voice Cloner API")

# ‚úÖ Enable CORS
app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],  # Use specific origins in production
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

# ‚úÖ Skip ngrok browser warning middleware
@app.middleware("http")
async def skip_ngrok_warning(request: Request, call_next):
    response = await call_next(request)
    response.headers["ngrok-skip-browser-warning"] = "true"
    return response

# ‚úÖ Redirect root to docs
@app.get("/", include_in_schema=False)
def root():
    return RedirectResponse(url="/docs")

# ‚úÖ Denoising endpoint
@app.post("/denoise/")
async def denoise_audio(file: UploadFile = File(...)):
    input_path = "input_audio.wav"
    with open(input_path, "wb") as f:
        f.write(await file.read())

    data, sr = librosa.load(input_path, sr=None)
    if len(data.shape) == 2:
        data = data[:, 0]

    noise_clip = data[:int(sr * 0.5)]
    reduced_noise = nr.reduce_noise(y=data, sr=sr, y_noise=noise_clip)

    output_path = "denoised_output.wav"
    sf.write(output_path, reduced_noise, sr)

    return FileResponse(output_path, media_type="audio/wav", filename="denoised_output.wav")

# ‚úÖ Voice cloning endpoint
@app.post("/clone-voice/")
async def clone_voice(text: str = Form(...), audio: UploadFile = File(...)):
    os.environ["COQUI_TOS_AGREED"] = "1"
    device = "cuda" if torch.cuda.is_available() else "cpu"
    tts = TTS("tts_models/multilingual/multi-dataset/xtts_v2").to(device)

    ref_audio_path = "reference.wav"
    with open(ref_audio_path, "wb") as f:
        f.write(await audio.read())

    output_path = "cloned_output.wav"
    tts.tts_to_file(text=text, speaker_wav=ref_audio_path, language="en", file_path=output_path)

    return FileResponse(output_path, media_type="audio/wav", filename="cloned_output.wav")

# ‚úÖ Start backend + Ngrok tunnel
ngrok.set_auth_token("2x3EY03t4Z9LMKmHBWJiXd03eMw_6ehcXKeBBubL4zjAyvtHT")
public_url = ngrok.connect(8000)
print("üöÄ Public URL:", public_url)

def run():
    uvicorn.run(app, host="0.0.0.0", port=8000)

threading.Thread(target=run).start()